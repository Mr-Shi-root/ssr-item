# 技术架构总结

## 一、技术栈全景图

```
┌─────────────────────────────────────────────────────────────┐
│                         用户层                               │
│                    浏览器 / 移动端                            │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                      CDN / 边缘层                            │
│              静态资源加速 + 骨架页缓存                         │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                      负载均衡层                               │
│                    Nginx 反向代理                            │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                      应用服务层                               │
│              Koa + React SSR (Node.js)                      │
│              PM2 集群模式 (多进程)                            │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                      缓存层                                  │
│              Redis (预检 + SSR + 数据缓存)                   │
│              LRU 内存缓存 (进程内)                            │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                      数据层                                  │
│              后端 API 服务 + 数据库                           │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                      监控层                                  │
│              Prometheus + Grafana                           │
└─────────────────────────────────────────────────────────────┘
```

---

## 二、技术栈分层详解

### 1. 前端技术栈

#### 1.1 核心框架
| 技术 | 版本 | 用途 | 说明 |
|------|------|------|------|
| **React** | 18.2.0 | UI 框架 | 支持 SSR 和 CSR，使用 Hooks |
| **React DOM** | 18.2.0 | 渲染引擎 | 服务端 renderToString，客户端 hydrateRoot |

#### 1.2 状态管理
| 技术 | 用途 | 说明 |
|------|------|------|
| **React Hooks** | 状态管理 | useState, useEffect, useCallback |
| **Context API** | 全局状态 | 可选，用于主题、用户信息等 |

#### 1.3 HTTP 请求
| 技术 | 版本 | 用途 | 说明 |
|------|------|------|------|
| **Axios** | 1.6.2 | HTTP 客户端 | 支持拦截器、超时控制 |

---

### 2. 服务端技术栈

#### 2.1 Web 框架
| 技术 | 版本 | 用途 | 说明 |
|------|------|------|------|
| **Koa** | 2.15.0 | Web 框架 | 轻量级，基于 async/await |
| **Koa Router** | 12.0.1 | 路由管理 | RESTful 路由 |
| **Koa Static** | 5.0.0 | 静态资源服务 | 提供静态文件访问 |

#### 2.2 SSR 渲染
| 技术 | 用途 | 说明 |
|------|------|------|
| **ReactDOMServer** | 服务端渲染 | renderToString / renderToPipeableStream |
| **Babel** | JSX 编译 | 将 JSX 编译为 JavaScript |

#### 2.3 进程管理
| 技术 | 用途 | 说明 |
|------|------|------|
| **PM2** | 进程管理 | 集群模式、自动重启、负载均衡 |
| **Nodemon** | 开发热重载 | 监听文件变化自动重启 |

---

### 3. 构建工具链

#### 3.1 打包工具
| 技术 | 版本 | 用途 | 说明 |
|------|------|------|------|
| **Webpack** | 5.89.0 | 模块打包 | 支持代码分割、Tree Shaking |
| **Webpack CLI** | 5.1.4 | 命令行工具 | 构建命令 |
| **webpack-node-externals** | 3.0.0 | 排除 node_modules | 服务端打包优化 |

#### 3.2 编译工具
| 技术 | 版本 | 用途 | 说明 |
|------|------|------|------|
| **Babel Core** | 7.23.6 | JavaScript 编译 | ES6+ 转 ES5 |
| **@babel/preset-env** | 7.23.6 | 环境预设 | 根据目标环境自动转换 |
| **@babel/preset-react** | 7.23.3 | React 预设 | JSX 转换 |
| **babel-loader** | 9.1.3 | Webpack Loader | 集成 Babel 到 Webpack |

#### 3.3 Webpack 插件
| 技术 | 版本 | 用途 | 说明 |
|------|------|------|------|
| **HtmlWebpackPlugin** | 5.6.0 | HTML 生成 | 自动注入 bundle |
| **css-loader** | 6.8.1 | CSS 处理 | 解析 CSS 文件 |
| **style-loader** | 3.3.3 | CSS 注入 | 将 CSS 注入到 DOM |

---

### 4. 缓存技术栈

#### 4.1 分布式缓存
| 技术 | 用途 | 说明 |
|------|------|------|
| **Redis** | 分布式缓存 | 预检结果、SSR 渲染结果、商品数据 |
| **ioredis** | Redis 客户端 | 支持集群、哨兵模式 |

#### 4.2 内存缓存
| 技术 | 用途 | 说明 |
|------|------|------|
| **LRU Cache** | 进程内缓存 | SSR 渲染结果缓存 |
| **node-cache** | 简单缓存 | 预检结果缓存 |

---

### 5. 基础设施

#### 5.1 Web 服务器
| 技术 | 用途 | 说明 |
|------|------|------|
| **Nginx** | 反向代理 | 负载均衡、静态资源服务、Gzip 压缩 |

#### 5.2 CDN
| 技术 | 用途 | 说明 |
|------|------|------|
| **Cloudflare** | CDN 加速 | 静态资源、骨架页缓存 |
| **Cloudflare Workers** | 边缘计算 | 预检接口前置（可选） |

#### 5.3 容器化
| 技术 | 用途 | 说明 |
|------|------|------|
| **Docker** | 容器化 | 应用打包、环境隔离 |
| **Docker Compose** | 容器编排 | 多容器管理 |

---

### 6. 监控与日志

#### 6.1 性能监控
| 技术 | 用途 | 说明 |
|------|------|------|
| **Prometheus** | 指标采集 | QPS、响应时间、错误率 |
| **Grafana** | 可视化 | 监控面板、告警 |
| **prom-client** | Node.js 客户端 | 暴露 metrics 接口 |

#### 6.2 日志管理
| 技术 | 用途 | 说明 |
|------|------|------|
| **Winston** | 日志库 | 结构化日志、日志分级 |
| **Morgan** | HTTP 日志 | Koa 请求日志中间件 |

---

### 7. 安全技术栈

#### 7.1 安全防护
| 技术 | 用途 | 说明 |
|------|------|------|
| **koa-helmet** | 安全头 | 设置安全相关的 HTTP 头 |
| **koa-csrf** | CSRF 防护 | 防止跨站请求伪造 |
| **xss** | XSS 过滤 | 过滤用户输入 |

#### 7.2 限流防刷
| 技术 | 用途 | 说明 |
|------|------|------|
| **koa-ratelimit** | 限流 | 基于 IP 的请求限流 |
| **Redis** | 限流存储 | 分布式限流计数 |

---

### 8. 开发工具

#### 8.1 开发辅助
| 技术 | 用途 | 说明 |
|------|------|------|
| **Concurrently** | 并发执行 | 同时启动多个开发服务 |
| **ESLint** | 代码检查 | 代码规范检查（可选） |
| **Prettier** | 代码格式化 | 统一代码风格（可选） |

#### 8.2 测试工具
| 技术 | 用途 | 说明 |
|------|------|------|
| **Jest** | 单元测试 | React 组件测试（可选） |
| **Puppeteer** | E2E 测试 | 端到端测试（可选） |
| **Supertest** | API 测试 | Koa 路由测试（可选） |

---

## 三、技术选型理由

### 3.1 为什么选择 Koa？
✅ **轻量级**：核心代码极简，易于理解和扩展
✅ **async/await**：原生支持，代码更优雅
✅ **中间件机制**：洋葱模型，灵活强大
✅ **性能优秀**：比 Express 更快，更适合高并发场景

### 3.2 为什么选择 React 18？
✅ **SSR 支持**：官方支持服务端渲染
✅ **Hydration**：客户端激活性能优秀
✅ **生态丰富**：组件库、工具链完善
✅ **流式渲染**：支持 renderToPipeableStream（可选）

### 3.3 为什么选择 Webpack？
✅ **成熟稳定**：生态完善，社区活跃
✅ **灵活配置**：支持多入口、代码分割
✅ **插件丰富**：满足各种构建需求
✅ **SSR 支持**：可以打包服务端代码

### 3.4 为什么选择 Redis？
✅ **高性能**：内存存储，读写速度快
✅ **数据结构丰富**：String、Hash、List、Set 等
✅ **分布式支持**：集群、哨兵模式
✅ **TTL 支持**：自动过期，适合缓存场景

---

## 四、技术架构对比

### 4.1 与传统 CSR 对比

| 维度 | 传统 CSR | 本架构 |
|------|---------|--------|
| 首屏渲染 | 慢（需要加载 JS） | 快（SSR 直接返回 HTML） |
| SEO | 差（需要额外处理） | 好（SSR 天然支持） |
| 服务端压力 | 小 | 中（SSR 有压力，但有缓存） |
| 开发复杂度 | 低 | 中（需要处理 SSR） |
| 适用场景 | 后台管理系统 | 电商、内容平台 |

### 4.2 与纯 SSR 对比

| 维度 | 纯 SSR | 本架构 |
|------|--------|--------|
| 服务端压力 | 大（所有请求都渲染） | 小（秒杀走 CSR） |
| 高并发支持 | 差（服务端瓶颈） | 好（秒杀场景 CDN 缓存） |
| 灵活性 | 低（单一策略） | 高（混合渲染） |
| 开发复杂度 | 中 | 高（需要两套方案） |
| 适用场景 | 中小型网站 | 大型电商平台 |

---

## 五、核心技术亮点

### 5.1 混合渲染架构
- ✅ 根据业务场景动态选择渲染策略
- ✅ 普通商品 SSR，秒杀商品 CSR
- ✅ 兼顾 SEO 和高并发

### 5.2 多级缓存策略
- ✅ CDN 缓存（骨架页静态资源）
- ✅ Redis 缓存（预检结果、SSR 渲染结果）
- ✅ LRU 内存缓存（进程内热数据）

### 5.3 智能路由分发
- ✅ 轻量级预检接口（<50ms）
- ✅ 支持多种判断策略
- ✅ 降级策略保证可用性

### 5.4 高可用架构
- ✅ Nginx 负载均衡
- ✅ PM2 集群模式
- ✅ Redis 主从复制
- ✅ 全链路监控

---

## 六、技术栈总览表

### 核心技术栈（必须）

| 分类 | 技术 | 版本 |
|------|------|------|
| **前端框架** | React | 18.2.0 |
| **服务端框架** | Koa | 2.15.0 |
| **构建工具** | Webpack | 5.89.0 |
| **编译工具** | Babel | 7.23.6 |
| **缓存** | Redis | - |
| **进程管理** | PM2 | - |
| **反向代理** | Nginx | - |

### 扩展技术栈（推荐）

| 分类 | 技术 | 用途 |
|------|------|------|
| **监控** | Prometheus + Grafana | 性能监控 |
| **CDN** | Cloudflare | 静态资源加速 |
| **容器化** | Docker | 应用部署 |
| **限流** | koa-ratelimit | 防刷 |
| **安全** | koa-helmet + xss | 安全防护 |

### 可选技术栈（优化）

| 分类 | 技术 | 用途 |
|------|------|------|
| **类型检查** | TypeScript | 类型安全 |
| **测试** | Jest + Puppeteer | 单元测试 + E2E |
| **日志** | Winston | 结构化日志 |
| **边缘计算** | Cloudflare Workers | 预检前置 |
| **数据层** | GraphQL | 统一数据查询 |

---

## 七、技术栈演进路线

### 阶段 1：MVP（最小可行产品）
- ✅ Koa + React SSR
- ✅ 基础路由判断
- ✅ 简单的内存缓存

### 阶段 2：性能优化
- ✅ 引入 Redis 缓存
- ✅ SSR 渲染缓存
- ✅ CDN 部署骨架页

### 阶段 3：高可用
- ✅ PM2 集群模式
- ✅ Nginx 负载均衡
- ✅ 监控告警体系

### 阶段 4：极致优化
- ✅ 边缘计算（Cloudflare Workers）
- ✅ 流式 SSR
- ✅ 微前端架构

---

## 八、面试话术

**面试官：你们用了哪些技术栈？**

**回答**：
"我们的技术栈分为几层：

**前端层**使用 React 18 作为 UI 框架，支持 SSR 和 CSR 两种渲染模式。

**服务端层**使用 Koa 作为 Web 框架，配合 ReactDOMServer 实现服务端渲染。使用 PM2 集群模式部署，充分利用多核 CPU。

**缓存层**使用 Redis 作为分布式缓存，存储预检结果和 SSR 渲染结果，配合 LRU 内存缓存做二级缓存。

**基础设施层**使用 Nginx 作为反向代理，负责负载均衡和静态资源服务。骨架页静态资源部署到 CDN，支持全球加速。

**监控层**使用 Prometheus 采集性能指标，Grafana 做可视化监控，实现全链路监控。

整体架构是一个'预检分流 + 混合渲染 + 多级缓存'的高可用架构。"

---

完整的技术栈清单和选型理由都在这里了！
