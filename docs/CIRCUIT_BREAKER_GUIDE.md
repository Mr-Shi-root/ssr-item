# 熔断器完整实现指南

## 修复的问题

### 原问题
1. ❌ `halfOpenRequests` 配置了但没有使用
2. ❌ 半开状态下所有请求都会尝试调用 API（没有限流）
3. ❌ 成功 1 次就恢复，不够稳健
4. ❌ 没有成功计数器

### 修复后
1. ✅ 半开状态限流：只允许 3 次尝试
2. ✅ 连续成功 2 次才恢复（可配置）
3. ✅ 半开状态失败立即重新熔断
4. ✅ 完整的状态机实现

---

## 完整的熔断器状态机

```
                    失败 < 5 次
                        ↓
            ┌───────────────────────┐
            │      CLOSED           │  正常状态
            │      (关闭)           │  所有请求正常通过
            └───────────────────────┘
                        ↓
                  失败 ≥ 5 次
                        ↓
            ┌───────────────────────┐
            │       OPEN            │  熔断状态
            │      (开启)           │  所有请求直接降级
            │                       │  不调用 API
            └───────────────────────┘
                        ↓
                  等待 30 秒
                        ↓
            ┌───────────────────────┐
            │    HALF_OPEN          │  半开状态
            │     (半开)            │  允许 3 次尝试
            │                       │  其他请求降级
            └───────────────────────┘
                   ↙        ↘
            成功 ≥ 2 次    失败 1 次
                 ↓            ↓
              CLOSED        OPEN
            (恢复正常)    (重新熔断)
```

---

## 配置参数详解

```javascript
const CIRCUIT_BREAKER_CONFIG = {
  failureThreshold: 5,      // 失败 5 次后熔断
  timeout: 30000,           // 熔断 30 秒后进入半开状态
  halfOpenRequests: 3,      // 半开状态允许 3 次尝试
  successThreshold: 2       // 半开状态连续成功 2 次后恢复
};
```

| 参数 | 说明 | 推荐值 | 调整建议 |
|------|------|--------|---------|
| `failureThreshold` | 失败多少次后熔断 | 5 | 接口稳定：10；不稳定：3 |
| `timeout` | 熔断多久后尝试恢复 | 30000ms | 快速恢复：10s；保守：60s |
| `halfOpenRequests` | 半开状态允许几次尝试 | 3 | 流量大：5；流量小：2 |
| `successThreshold` | 连续成功几次后恢复 | 2 | 要求高：3；宽松：1 |

---

## 状态转换详解

### 1. CLOSED → OPEN（触发熔断）

**条件**：连续失败 5 次

```javascript
// 场景：预检接口连续失败
请求 1: 失败 (failureCount = 1)
请求 2: 失败 (failureCount = 2)
请求 3: 失败 (failureCount = 3)
请求 4: 失败 (failureCount = 4)
请求 5: 失败 (failureCount = 5) → 触发熔断，state = OPEN

// 日志输出
⚠️ 失败次数: 1/5
⚠️ 失败次数: 2/5
⚠️ 失败次数: 3/5
⚠️ 失败次数: 4/5
🔴 失败次数达到阈值 (5/5)，熔断器开启 (OPEN)
```

**效果**：
- 后续所有请求直接降级，不调用 API
- 保护后端服务，避免雪崩

---

### 2. OPEN → HALF_OPEN（尝试恢复）

**条件**：熔断 30 秒后

```javascript
// 时间线
T0: 熔断器开启 (state = OPEN)
T0 ~ T30: 所有请求降级
T30: 自动进入半开状态 (state = HALF_OPEN)

// 日志输出
⚠️ 熔断器开启，使用降级策略  (T0 ~ T29)
🔄 熔断器进入半开状态  (T30)
```

**效果**：
- 给后端服务恢复时间
- 30 秒后尝试恢复

---

### 3. HALF_OPEN 状态的限流机制（关键修复）

**核心逻辑**：只允许 3 次请求尝试调用 API，其他请求继续降级

```javascript
// 半开状态下的请求处理
请求 1: 尝试调用 API (halfOpenAttempts = 1)
请求 2: 尝试调用 API (halfOpenAttempts = 2)
请求 3: 尝试调用 API (halfOpenAttempts = 3)
请求 4: 降级 (halfOpenAttempts = 3，已达上限)
请求 5: 降级 (halfOpenAttempts = 3，已达上限)
...

// 日志输出
🔄 半开状态尝试 1/3
🔄 半开状态尝试 2/3
🔄 半开状态尝试 3/3
⚠️ 半开状态尝试次数已达上限 (3/3)，使用降级策略
⚠️ 半开状态尝试次数已达上限 (3/3)，使用降级策略
```

**为什么要限流？**
- 避免大量请求同时冲击刚恢复的后端服务
- 用少量请求探测服务是否真的恢复
- 如果服务还没恢复，只有 3 个请求失败，不会造成大量失败

---

### 4. HALF_OPEN → CLOSED（恢复正常）

**条件**：连续成功 2 次

```javascript
// 半开状态下的成功处理
请求 1: 成功 (successCount = 1)
请求 2: 成功 (successCount = 2) → 恢复正常，state = CLOSED

// 日志输出
✅ 半开状态成功 1/2
✅ 半开状态成功 2/2
✅ 熔断器恢复正常 (CLOSED)
```

**为什么要连续成功 2 次？**
- 避免偶然成功导致误判
- 确保服务真的稳定了
- 更稳健的恢复策略

---

### 5. HALF_OPEN → OPEN（重新熔断）

**条件**：半开状态下任意 1 次失败

```javascript
// 半开状态下的失败处理
请求 1: 成功 (successCount = 1)
请求 2: 失败 → 立即重新熔断，state = OPEN

// 日志输出
✅ 半开状态成功 1/2
🔴 半开状态失败，熔断器重新开启 (OPEN)
```

**为什么失败 1 次就重新熔断？**
- 说明服务还没恢复
- 立即保护，避免更多失败
- 再等 30 秒后重试

---

## 实际运行示例

### 场景 1：正常恢复流程

```
时间轴：
00:00 - 服务正常 (CLOSED)
00:10 - 预检接口开始出问题
00:10 - 失败 1 次 (1/5)
00:11 - 失败 2 次 (2/5)
00:12 - 失败 3 次 (3/5)
00:13 - 失败 4 次 (4/5)
00:14 - 失败 5 次 (5/5) → 熔断 (OPEN)
00:14 ~ 00:44 - 所有请求降级（30秒）
00:44 - 进入半开状态 (HALF_OPEN)
00:44 - 请求 1 成功 (1/2)
00:45 - 请求 2 成功 (2/2) → 恢复正常 (CLOSED)
00:45 ~ - 服务恢复正常

总恢复时间：35 秒
```

---

### 场景 2：半开状态失败，重新熔断

```
时间轴：
00:00 - 熔断器开启 (OPEN)
00:30 - 进入半开状态 (HALF_OPEN)
00:30 - 请求 1 成功 (1/2)
00:31 - 请求 2 失败 → 重新熔断 (OPEN)
00:31 ~ 01:01 - 再次降级（30秒）
01:01 - 再次进入半开状态 (HALF_OPEN)
01:01 - 请求 1 成功 (1/2)
01:02 - 请求 2 成功 (2/2) → 恢复正常 (CLOSED)

总恢复时间：62 秒（两轮尝试）
```

---

### 场景 3：半开状态限流保护

```
时间轴：
00:00 - 进入半开状态 (HALF_OPEN)
00:00 - 请求 1: 尝试调用 API (1/3)
00:00 - 请求 2: 尝试调用 API (2/3)
00:00 - 请求 3: 尝试调用 API (3/3)
00:00 - 请求 4: 降级（已达上限）
00:00 - 请求 5: 降级（已达上限）
00:00 - 请求 6: 降级（已达上限）
...
00:01 - 前 3 个请求都成功 → 恢复正常 (CLOSED)
00:01 - 请求 7: 正常调用 API

保护效果：
- 只有 3 个请求尝试调用 API
- 其他请求降级，不冲击后端
- 服务恢复后立即正常
```

---

## 缓存命中也算成功（重要优化）

```javascript
// 3. 查询 Redis 缓存
const cached = await cacheHelper.get(cacheKey, 'precheck');
if (cached) {
  // 缓存命中也算成功，帮助熔断器恢复
  handleCircuitBreakerSuccess();
  return cached;
}
```

**为什么缓存命中也算成功？**
1. 缓存命中说明系统运行正常
2. 帮助熔断器更快恢复
3. 避免因为缓存命中率高而无法恢复

**效果**：
- 缓存命中率 95% 时，熔断器恢复更快
- 不需要等待缓存未命中才能恢复

---

## 监控和调试

### 1. 查看熔断器状态

```bash
curl http://localhost:3000/monitor/circuit-breaker
```

**响应示例**：
```json
{
  "state": "HALF_OPEN",
  "failureCount": 5,
  "successCount": 1,
  "lastFailureTime": 1701234567890,
  "halfOpenAttempts": 2,
  "config": {
    "failureThreshold": 5,
    "timeout": 30000,
    "halfOpenRequests": 3,
    "successThreshold": 2
  }
}
```

### 2. 手动重置熔断器

```bash
curl -X POST http://localhost:3000/admin/circuit-breaker/reset
```

**使用场景**：
- 确认后端服务已恢复
- 不想等待 30 秒
- 紧急恢复服务

---

## 告警规则

```javascript
// 监控脚本
setInterval(async () => {
  const status = await getCircuitBreakerStatus();

  // 告警 1：熔断器开启
  if (status.state === 'OPEN') {
    sendAlert('🔴 预检接口熔断器开启，所有请求降级');
  }

  // 告警 2：半开状态
  if (status.state === 'HALF_OPEN') {
    sendAlert('🔄 预检接口熔断器半开，正在尝试恢复');
  }

  // 告警 3：失败次数接近阈值
  if (status.state === 'CLOSED' && status.failureCount >= 3) {
    sendAlert(`⚠️ 预检接口失败次数: ${status.failureCount}/5，接近熔断阈值`);
  }
}, 10000);  // 每 10 秒检查一次
```

---

## 性能影响

### 熔断前 vs 熔断后

| 指标 | 熔断前（接口挂了） | 熔断后 | 改善 |
|------|------------------|--------|------|
| 响应时间 | 3000ms（超时） | 1ms（降级） | **99.97%** ⬆️ |
| 错误率 | 100% | 0%（降级成功） | **100%** ⬇️ |
| 服务可用性 | 不可用 | 可用（降级） | ✅ |
| 后端压力 | 持续冲击 | 0 | ✅ |

---

## 最佳实践

### 1. 根据场景调整参数

**高可用场景（金融、支付）**：
```javascript
{
  failureThreshold: 3,      // 失败 3 次就熔断（更敏感）
  timeout: 60000,           // 熔断 60 秒（更保守）
  halfOpenRequests: 2,      // 只允许 2 次尝试
  successThreshold: 3       // 连续成功 3 次才恢复
}
```

**普通场景（电商、内容）**：
```javascript
{
  failureThreshold: 5,      // 失败 5 次熔断
  timeout: 30000,           // 熔断 30 秒
  halfOpenRequests: 3,      // 允许 3 次尝试
  successThreshold: 2       // 连续成功 2 次恢复
}
```

**宽松场景（内部工具）**：
```javascript
{
  failureThreshold: 10,     // 失败 10 次熔断
  timeout: 10000,           // 熔断 10 秒
  halfOpenRequests: 5,      // 允许 5 次尝试
  successThreshold: 1       // 成功 1 次就恢复
}
```

### 2. 配合监控使用

- 熔断器开启时立即告警
- 记录熔断频率和时长
- 分析熔断原因（接口慢？挂了？）

### 3. 降级策略要可靠

```javascript
function getFallbackStrategy(itemId) {
  // ✅ 好的降级策略：简单、可靠、不依赖外部服务
  const isSeckill = itemId.startsWith('SK');
  return { renderStrategy: isSeckill ? 'csr' : 'ssr' };
}

// ❌ 坏的降级策略：依赖其他服务
function getFallbackStrategy(itemId) {
  // 如果这个接口也挂了怎么办？
  const data = await anotherAPI.get(itemId);
  return data;
}
```

---

## 总结

### 修复前后对比

| 特性 | 修复前 | 修复后 |
|------|--------|--------|
| 半开状态限流 | ❌ 没有 | ✅ 只允许 3 次尝试 |
| 恢复条件 | ❌ 成功 1 次就恢复 | ✅ 连续成功 2 次 |
| 半开失败处理 | ❌ 不明确 | ✅ 立即重新熔断 |
| 成功计数 | ❌ 没有 | ✅ 有 |
| 缓存命中处理 | ❌ 不算成功 | ✅ 算成功 |

### 核心价值

1. **保护后端服务**：避免持续冲击已经挂了的服务
2. **快速失败**：1ms 降级 vs 3000ms 超时
3. **自动恢复**：30 秒后自动尝试恢复
4. **稳健恢复**：连续成功 2 次才恢复，避免误判
5. **限流保护**：半开状态只允许 3 次尝试，不冲击后端

这是一个**生产级别的熔断器实现**，可以直接用于高并发场景！
